#!/usr/bin/ruby
# DYLOGGER 0.9: An IFTTT-to-Day One Logger by Chris Jones
# Based on sifffter by Craig Eley 2014 <http://craigeley.com>
# and giftttdy by Leon/GadgetComa <http://giftttdy.gadgetcoma.com/>
#
# Notes:
# * DYLOGGER generates DayOne journal entries triggered by hazel
# * you need to supply a path to where dayone is, and where the hazel files will be
# *
# * unlike siffter, which generates a daily report when run using some sort of scheduler
# * DYLOGGER is designed to be run when hazel detects an appropriate file (like ggcifftdy)
# * hence its kind of the lovechild of the two
# *
# * depending on the way data is passed, it can either generate a "digest" (that is, append new entries to a single daily digest)
# * or a "service" which creates a new entry for each file passed
# * 
# * it can read two kinds of files
# * .txt FILES
# * should be in the format as specified by giftty, meaning you can use gadgetcomas existing IFFFT recipes
# * and make your own with this format. This format has data separated by the triple pipe "|||" in the format:
# * title|||tag, tag, tag|||date (or NODATE)|||image url or NOPIC|||entry text|||format
# * the last one is "true" for a digest or "service" for a service
# * 
# * .json FILES
# * designed to parse JSON files in Dropbox generated by the "reporter" app <http://http://www.reporter-app.com/>
# * 
# * Does not require the Day One CLI tool
# *
# *

require 'rubygems'
require 'optparse'
require 'time'
require 'erb'
include ERB::Util
require 'date'
require 'optparse'
require 'json'

# set these to your local username
user="chrisjones"
$dayonepath = "/Users/#{user}/Dropbox/Apps/Day\ One/Journal.dayone/"
$dyloggerpath = "/Users/#{user}/Dropbox/Apps/IFTTT/dylogger/"

# don't change these
$dyloggerdatapath = "#{$dyloggerpath}data/"
$serviceheader = "##### "

#this is used to separate out different services within the one day one entry - it's not visible in the entry view
$servicemarker = "\n[//]: #\n"

def main

  if !Dir.exists?($dyloggerdatapath) 
    Dir.mkdir($dyloggerdatapath)
  end


  template = ERB.new <<-XMLTEMPLATE
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Creation Date</key>
	<date><%= Time.parse(entry_data['date']).utc.strftime('%Y-%m-%dT%H:%I:%S') %>Z</date>
	<key>Entry Text</key>
	<string><%= entrytext %></string>
  <% if entry_data['location']%><key>Location</key>
  <dict>
    <key>Administrative Area</key>
    <string><%= h(entry_data["location"]["administrativeArea"])%></string>
    <key>Country</key>
    <string><%= h(entry_data["location"]["country"])%></string>
    <key>Latitude</key>
    <real><%= h(entry_data["location"]["latitude"])%></real>
    <key>Locality</key>
    <string><%= h(entry_data["location"]["locality"])%></string>
    <key>Longitude</key>
    <real><%= h(entry_data["location"]["longitude"])%></real>
    <key>Place Name</key>
    <string><%= h(entry_data["location"]["name"])%></string>
  </dict><% end %>
 	<key>Starred</key>
	<false/>
	<key>Tags</key>
	<array><% tags.each do |tag| %>\n\t\t<string><%= tag %></string><% end %>
   </array>
  <key>Time Zone</key>
  <string><%= tz%></string>
	<key>UUID</key>
	<string><%= uuid %></string>
  <% if entry_data['weather']%><key>Weather</key>
  <dict>
    <key>Celsius</key>
    <string><%= h(entry_data["weather"]["tempC"])%></string>
    <key>Description</key>
    <string><%= h(entry_data["weather"]["weather"])%></string>
    <key>Fahrenheit</key>
    <string><%= h(entry_data["weather"]["tempF"])%></string>
  </dict><% end %>
</dict>
</plist>
XMLTEMPLATE

# note h() in the template encodes html
t = <<-ENTRYTEMPLATE
<% if entry_data['text_only']%><%= h(entry_data["text"])%><% else %>* __<%= entry_data['parsed_date'].strftime("%R")%>__ <%= h(entry_data["text"])%><% end %>\n
ENTRYTEMPLATE

  # by default (!!) erb adds a newline - the options at the end prevent this
  entrytemplate = ERB.new( t,0,'>')

  #filepath = "#{$dyloggerpath}log.txt"
  #f = File.new(File.expand_path(filepath),'w+')
  #f.puts 'logging successful'
  #f.close

  ARGV.each do |srcfile|

    if File.exists?(srcfile)

      ext = File.extname(srcfile)

      case ext
      when'.json'
        entry_data = parseJSONFile(srcfile)
      else
        entry_data = parseTxtFile(srcfile)
      end #case

      entry_data = checkEntryData(entry_data)

      if entry_data['date'].upcase=='NODATE'
        entry_data['date']=DateTime.now.strftime('%Y-%m-%dT%H:%I:%S%z')
      end

      # add stuff we need
      entry_data['parsed_date'] = DateTime.parse(entry_data["date"])
      entry_data['Y-m-d'] = entry_data['parsed_date'].strftime("%Y-%m-%d")
      entry_data['is_service'] = false

      #p entry_data

      # if format is "service", always create a new entry
      if entry_data['format'].chomp.strip.downcase=='service'
        entry_data['uuid'] = uuid= %x{uuidgen}.gsub(/-/,'').strip
        entry_data['is_service'] = true
        entry_data['text_only'] = true
      else
        entry_data['uuid'] = uuid = getDigestUUID(entry_data['Y-m-d'])
      end


      filepath = "#{$dayonepath}entries/#{uuid}.doentry"
      newfile=''

      if File.exists?(filepath)
        # an entry exists for this date already
        f = File.open(filepath, encoding: 'UTF-8')
        lines2 = f.read
        f.close

        #prepare to iterate the file, looking for the service that corresponds to the existing entry
        found = false
        # TODO: need to check that the file actually contains something
        services=lines2.split($servicemarker)

        # pop the last "service" as its actually everything after the existing services
        lastservice = services.pop

        services.each do |service|

          line = service.lines.first

          if line.include? $serviceheader
            if line.gsub(/[^0-9a-z ]/i, '').strip == entry_data['service']
              found = true
              service += entrytemplate.result(binding)
              p entrytemplate.result(binding)
            end
            
          end

          newfile += service + $servicemarker

        end

        # we didnt find an existing service among the services - make a new one at the end
        if !found
          p 'we didnt find an existing service in the entry'
          service = $serviceheader +  entry_data["service"] + "\n\n"
          service += entrytemplate.result(binding)
          
          newfile += service + $servicemarker

        end

        # find existing tags and add any new tags

        elems=lastservice.split('<key>')
        elems.each_with_index do |elem, index|
          if elem.include? 'Tags</key>'
            tags=elem.split('<string>')
            #remove the first element, as it contains <key>Tags</key>
            tags.shift
            #remove xml tags and whitespace to leave an array of tags
            tags = tags.map {|s| s.gsub(/<.+?>/, '').gsub(/[^0-9a-z ]/i, '').strip}

            #add any new tags
            tags = mergeTags(tags,entry_data["tags"])

            # rebuild tags
            elems[index] = "Tags</key>\n\t<array>\n"
            tags.each {|tag| elems[index] += "\t\t<string>" + tag + "</string>\n"}
            elems[index] += "\t</array>\n\t"

          end

        end

        newfile += elems.join('<key>')

        fh = File.new(File.expand_path(filepath),'w+')
        fh.puts newfile
        fh.close

      else
        p 'create new file/n'

        # we need to create a file with this entry
        # service = "# Lifestream" + $servicemarker
        # service += $serviceheader +  entry_data['service'] + "\n\n"

        service = $servicemarker + $serviceheader +  entry_data['service'] + "\n\n"
        service += entrytemplate.result(binding)
        
        entrytext = service + $servicemarker

        #tags
        tags = mergeTags(["Lifestream"],entry_data["tags"])

        # get the timezone
        cmd = "ls -al /etc/localtime"
        tzdata =  `#{cmd}`
        tzarray = tzdata.split('/')
        country=tzarray.pop 
        city=tzarray.pop
        tz= city + '/' + country
        tz.chomp

        f = File.new(File.expand_path(filepath),'w+')
        f.puts template.result(binding)
        f.close

        #if there's an image, download and check it
        if (entry_data['image']!='NOPIC')
          cmd = '/usr/bin/curl -L "' + entry_data['image'].strip.chomp + '"'
          i =  `#{cmd}`

          filepath = "#{$dayonepath}photos/#{uuid}.jpg"
          f = File.new(File.expand_path(filepath),'w+')
          f.write i
          f.close

          
          #file large enough?
          if File.size(filepath)<2048
            File.delete(filepath)
          else
            # if the file is not a jpeg or png, delete it
            p getImageType(filepath)
            case getImageType(filepath)
              when 'jpg'

              when 'png'

              else
                 File.delete(filepath)
            end
          end
        end

        #if its not a service entry (ie. a 'digest' entry), then store the uuid so we can add to it later
        if !entry_data['is_service']
          putDigestUUID(entry_data['Y-m-d'],entry_data['uuid'])
        end

      end # file exists (doentry)

    end #if file exists (srcfile)

  end #do files

end #main

# functions

def getImageType(file)
  
  bytes=IO.read(file, 10)

  patterns={'^GIF8' => 'gif',
            '^\x89PNG'=>'png',
            '^\xFF\xD8\xFF\xE0\x00\x10JFIF' =>'jpg',
            '^\xFF\xD8\xFF\xE1(.*){2}Exif' => 'jpg',
            '^BM' => 'bmp'
            }

  patterns.each_pair do|pattern,type|
    reg = Regexp.new pattern, nil, 'n'
    if reg.match(bytes) 
      return type
    end

  end

  return'unknown'
 
end


def parseJSONFile(srcfile)

    f = File.open(srcfile, encoding: 'UTF-8')
    json = f.read
    f.close

    entry_data=[]

    parsed = JSON.parse(json)

    parsed.each_pair do |json_key,json_value|

      case json_key

      when'snapshots' #reporter file
        entry_data = parseReporterJSON(json_value)
      else #case json_key

      end #case json_key

    end 

    return entry_data

end

def parseReporterJSON(json)

# template for reporter question -> response pairs
t = <<-TEMPLATE
\t* __<%= response_data['question']%>__ <%= response_data['answer']%>\n
TEMPLATE

  template = ERB.new( t,0,'>')

  # setup the array to return
  entry_values=["Reporter","Reporter"]
  entry_data=Hash[defineEntryKeys().zip(entry_values)]
  reports=[]

  json.each_with_index do |snapshot,index|

    entry_text=""

    snapshot.each_pair do |reporter_key,reporter_data|
      
      case reporter_key
        when 'responses'
          
          reporter_data.each do |response|
            
            response_data= Hash.new

            response.each_pair do |response_key, response_value|
              
              case response_key
                when "questionPrompt"
                  response_data['question'] = response_value
                when "numericResponse"
                  response_data['answer'] = response_value
                when "tokens"
                  tokens = []
                  response_value.each do |token|
                      tokens.push(token['text'])
                  end
                  response_data['answer'] = tokens.join(', ')
                when "answeredOptions"
                  response_data['answer'] = response_value[0]
                when "locationResponse"
                  response_value.each_pair do |location_key,location_value|
                    if location_key=='text'
                      response_data['answer'] = location_value
                    end
                  end
                  
                else

              end #case response_key

            end #response do

            entry_text += template.result(binding)
            response_data = nil

          end #reporter_data do
        
        when 'date'
          entry_data['date']=reporter_data

        when 'location'
          entry_data['location']=reporter_data
          reporter_data['placemark'].each_pair do |placemark_key,placemark_value|
            entry_data['location'][placemark_key]=placemark_value
          end

        when 'weather'
          entry_data['weather']=reporter_data

        when 'photoSet'
          response_data= Hash.new
          response_data['question'] = 'Photos taken'
          response_data['answer'] = reporter_data["photos"].length
          entry_text += template.result(binding)
          response_data = nil

        else  #case reporter_key

      end #case reporter_key

    end #do snapshot

    entry_data['parsed_date'] = DateTime.parse(entry_data["date"])
    entry_text = "* __" + entry_data['parsed_date'].strftime("%R") + "__" + "\n" + entry_text +"\n\n"

    reports.push(entry_text)

  end #do json

  entry_data['text_only'] = true
  entry_data['text'] = reports.join("\n")

  #p entry_data

  return entry_data

end

def parseTxtFile(srcfile)

      f = File.open(srcfile, encoding: 'UTF-8')
      lines = f.read
      f.close

      #line = lines.lines.first

      if lines =~ /&/
        lines.gsub!(/[&]/, 'and')
      end

      # split the line using triple pipe
      entry_values=lines.split("|||")

      entry_data=Hash[defineEntryKeys().zip(entry_values)]

      return entry_data
end

def defineEntryKeys ()

  return ["service","tags","date","image","text","format","template"]

end

def checkEntryData (entry_data)

      entry_defaults=["Default","",DateTime.now.strftime('%Y-%m-%dT%H:%I:%S%z'),"NOPIC","","TRUE",""]

      default_data=Hash[defineEntryKeys().zip(entry_defaults)]

      default_data.each_pair do |key,value|
        if !entry_data[key]
          entry_data[key] = value
        end
      end

      return entry_data

end

def mergeTags(tags, tagstring)

  tagstring.split(",").each do |tag|
    tag=tag.strip
    if !tags.include? tag 
      tags.push(tag)
    end
  end

  return tags
end


def putDigestUUID(digest_date, digest_uuid)

  filepath = "#{$dyloggerdatapath}#{digest_date}.txt"

  f = File.open(filepath,'w')
  f.write(digest_uuid)
  f.close

end

def getDigestUUID(digest_date)

  uuidfilepath = "#{$dyloggerdatapath}#{digest_date}.txt"

  if File.exists?(uuidfilepath)
      f = File.open(uuidfilepath)
      uuid = f.read.chomp
      f.close

      filepath = "#{$dayonepath}entries/#{uuid}.doentry"

      if File.exists?(filepath)

      else
        uuid = %x{uuidgen}.gsub(/-/,'').strip
        File.delete(uuidfilepath)
       
      end
  else
    uuid = %x{uuidgen}.gsub(/-/,'').strip
  end

  return uuid

end

def saveLog(message)
  filepath = "#{$dyloggerdatapath}log.txt"
  f = File.new(File.expand_path(filepath),'a')
  f.puts message
  f.close
end

main
